# Python + Versionator Example

This example demonstrates two approaches to integrate versionator with a Python project.

## Approach 1: Generated Source File (Recommended)

Generate a `_version.py` file at build time using `versionator emit`.

### How It Works

1. `VERSION` file contains the version (managed by versionator)
2. At build time, run `versionator emit python -o mypackage/_version.py`
3. Python code imports from the generated file

### Usage

```bash
# Create VERSION file
echo "1.0.0" > VERSION

# Generate _version.py using versionator emit
versionator emit python --output mypackage/_version.py

# Or use a custom template file
versionator emit --template-file mypackage/_version.tmpl.py --output mypackage/_version.py

# Build package
python -m build

# Run
python -m mypackage.main
```

### Files

```
mypackage/
├── __init__.py          # Imports __version__ from _version.py
├── _version.py          # Generated by versionator (git-ignored)
├── _version.tmpl.py     # Optional: custom template
└── main.py              # Application code
```

### Advantages

- Version is baked into the package at build time
- No runtime dependencies on VERSION file
- Works with all Python packaging tools
- Version available via `mypackage.__version__`

---

## Approach 2: Environment Variable

Pass version via environment variable at runtime or build time.

### How It Works

1. Set `APP_VERSION` environment variable
2. Python code reads from environment with fallback

### Usage

```bash
# Set version from versionator
export APP_VERSION=$(versionator version)

# Run application
python -m mypackage.main

# Or inline
APP_VERSION=$(versionator version) python -m mypackage.main
```

### Code Example

```python
import os

__version__ = os.environ.get("APP_VERSION", "0.0.0-dev")
```

### Advantages

- No file generation needed
- Easy to override for testing
- Works well in containerized environments

### Disadvantages

- Requires environment setup at runtime
- Version not embedded in installed package

---

## Quick Reference

| Approach | Command | Best For |
|----------|---------|----------|
| Generated file | `versionator emit python -o _version.py` | PyPI packages, libraries |
| Template file | `versionator emit -f _version.tmpl.py -o _version.py` | Custom format needs |
| Environment var | `APP_VERSION=$(versionator version)` | Containers, scripts |

## Using Make

```bash
make build      # Generate _version.py and build package
make run        # Generate _version.py and run
make clean      # Remove generated files
```

## Using Just

```bash
just build         # Generate _version.py and build package
just run           # Generate _version.py and run
just release-patch # Bump version and rebuild
```

## CI/CD Integration

### GitHub Actions

```yaml
- name: Build Python package
  run: |
    versionator emit python --output mypackage/_version.py
    python -m build

- name: Publish to PyPI
  uses: pypa/gh-action-pypi-publish@release/v1
```

### Docker

```dockerfile
FROM python:3.11-slim
COPY . /app
WORKDIR /app

# Option 1: Generate at build time
RUN versionator emit python -o mypackage/_version.py && pip install .

# Option 2: Pass at runtime
ENV APP_VERSION=${VERSION:-0.0.0}
```

## pyproject.toml Configuration

The example `pyproject.toml` reads version from the generated `_version.py`:

```toml
[tool.setuptools.dynamic]
version = {attr = "mypackage._version.__version__"}
```

Alternative: Read directly from VERSION file (no generation needed):

```toml
[tool.setuptools.dynamic]
version = {file = "VERSION"}
```

Then access at runtime via:

```python
from importlib.metadata import version
__version__ = version("mypackage")
```
